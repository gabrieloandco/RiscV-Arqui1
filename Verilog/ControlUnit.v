// File: ControlUnit.v
// Generated by MyHDL 1.0dev
// Date: Wed Nov  2 10:08:51 2016


`timescale 1ns/10ps

module ControlUnit (
    OPcode,
    funct7,
    funct3,
    branch,
    RegWrite,
    RegDest,
    ALUsrc,
    ALUop,
    DWidth,
    MemWrite,
    MemRead,
    PCsrc,
    Sel_Mux
);
// Entradas: OPcode, funct7, funct3, branch.
// Salidas: RegWrite, RegDest, ALUsrc, ALUop, DWidth, MemWrite, MemRead, PCsrc, Sel_Mux, PC_next.
// 
// Longitudes de las salidas:
// RegWrite, 1 bit.
// RegDest, 3 bits.
// ALUsrc, 1 bits.
// ALUop, 4 bits.
// DWidth, 3 bits.
// MemWrite, 1 bit.
// MemRead, 1 bit.
// PCsrc, 1 bits.
// Sel_Mux, 1 bit.

input [6:0] OPcode;
input [6:0] funct7;
input [2:0] funct3;
input [0:0] branch;
output [0:0] RegWrite;
reg [0:0] RegWrite;
output [2:0] RegDest;
reg [2:0] RegDest;
output [0:0] ALUsrc;
reg [0:0] ALUsrc;
output [3:0] ALUop;
reg [3:0] ALUop;
output [2:0] DWidth;
reg [2:0] DWidth;
output [0:0] MemWrite;
reg [0:0] MemWrite;
output [0:0] MemRead;
reg [0:0] MemRead;
output [0:0] PCsrc;
reg [0:0] PCsrc;
output [0:0] Sel_Mux;
reg [0:0] Sel_Mux;



// Para el set de instrucciones de tipo R es necesaria la funct3 y funct7, pero para el funcionamiento del codigo 
// no es estrictamente necesario. Por esa razón la mayoria de los condiciones dentro de if OPcode == C_OPcode.R_type 
// evaluan ambas codiciones.
// Para todas las operaciones tipo R ALUsrc.next = 0b0 y DWidth no es utilizado.
always @(branch, funct3, funct7, OPcode) begin: CONTROLUNIT_BEHAVIOR
    RegWrite = 0;
    RegDest = 4;
    ALUsrc = 0;
    ALUop = 0;
    DWidth = 5;
    MemWrite = 0;
    MemRead = 0;
    PCsrc = 1;
    Sel_Mux = 0;
    if ((OPcode == 51)) begin
        RegWrite = 1;
        RegDest = 4;
        ALUsrc = 0;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 1;
        Sel_Mux = 0;
        if (((funct3 == 0) && (funct7 == 0))) begin
            ALUop = 0;
        end
        else if (((funct3 == 0) && (funct7 == 32))) begin
            ALUop = 1;
        end
        else if (((funct3 == 1) && (funct7 == 0))) begin
            ALUop = 6;
        end
        else if (((funct3 == 2) && (funct7 == 0))) begin
            ALUop = 8;
        end
        else if (((funct3 == 3) && (funct7 == 0))) begin
            ALUop = 9;
        end
        else if (((funct3 == 4) && (funct7 == 0))) begin
            ALUop = 2;
        end
        else if (((funct3 == 5) && (funct7 == 0))) begin
            ALUop = 5;
        end
        else if (((funct3 == 5) && (funct7 == 32))) begin
            ALUop = 7;
        end
        else if (((funct3 == 6) && (funct7 == 0))) begin
            ALUop = 3;
        end
        else if (((funct3 == 7) && (funct7 == 0))) begin
            ALUop = 4;
        end
        else begin
            ALUop = 0;
        end
    end
    // El set de instrucciones de tipo I posee instrucciones que usan un immediato de 12 bits (imm[11:0]) 
    // y unos que usan dos immediatos uno de 5 bits (imm[4:0] = shamt = shift amount), otro de 7 bits (imm[11:5]) que 
    // indica si usar SLLI/SRLI o SRAI
    // DWidth es irrelevante.
    if ((OPcode == 19)) begin
        RegWrite = 1;
        RegDest = 4;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 1;
        ALUsrc = 1;
        Sel_Mux = 0;
        if ((funct3 == 0)) begin
            ALUop = 0;
        end
        else if ((funct3 == 2)) begin
            ALUop = 8;
        end
        else if ((funct3 == 3)) begin
            ALUop = 9;
        end
        else if ((funct3 == 4)) begin
            ALUop = 2;
        end
        else if ((funct3 == 6)) begin
            ALUop = 3;
        end
        else if ((funct3 == 7)) begin
            ALUop = 4;
        end
        else if (((funct3 == 1) && (funct7 == 0))) begin
            ALUop = 6;
        end
        else if (((funct3 == 5) && (funct7 == 0))) begin
            ALUop = 5;
        end
        else if (((funct3 == 5) && (funct7 == 32))) begin
            ALUop = 7;
        end
        else begin
            ALUop = 0;
        end
    end
    // En la instruccion JALR que es de tipo I se usa la operacion de ADD para sumar el registro de direccion rs1 con imm[11:0] de 12 bits, y colocar el 
    // LSB en 0, esto ultimo se realiza colocando el cable a tierra en el bus de datos, para no agregar una operacion mas a la ALU.
    // Para este tipo de instruccion no importa el valor que tenga la variable Dwidth, Sel_Mux.
    if (((OPcode == 103) && (funct3 == 0))) begin
        RegWrite = 1;
        RegDest = 0;
        ALUsrc = 1;
        ALUop = 0;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 0;
    end
    // Para las instrucciones de carga (I_type_LOAD) se obtendra la dirección del dato a cargar sumando el inmediato (extendido con signo) con el registro rs1
    // y se recibe de la memoria un BYTE, HALFWORD o WORD dependiendo de la función el cual se extiende con signo o sin signo
    if ((OPcode == 3)) begin
        RegWrite = 1;
        RegDest = 3;
        ALUsrc = 1;
        ALUop = 0;
        MemWrite = 0;
        MemRead = 1;
        PCsrc = 1;
        Sel_Mux = 0;
        case (funct3)
            'h0: begin
                DWidth = 0;
            end
            'h1: begin
                DWidth = 1;
            end
            'h2: begin
                DWidth = 2;
            end
            'h4: begin
                DWidth = 3;
            end
            'h5: begin
                DWidth = 4;
            end
            default: begin
                DWidth = 5;
            end
        endcase
    end
    // Para las instrucciones de tipo S (store) solo se ultiliza la escritura en la memoria, por lo que deshabilitamos RegWrite/MemRead y las salidas
    // RegDest/ALUsrc/ALUop/Ext_E
    if ((OPcode == 35)) begin
        RegWrite = 0;
        RegDest = 3;
        ALUsrc = 1;
        ALUop = 0;
        DWidth = 0;
        MemWrite = 1;
        MemRead = 0;
        PCsrc = 1;
        Sel_Mux = 0;
        case (funct3)
            'h0: begin
                DWidth = 0;
            end
            'h1: begin
                DWidth = 1;
            end
            'h2: begin
                DWidth = 2;
            end
            default: begin
                DWidth = 5;
            end
        endcase
    end
    // Para la instruccion branch, tipo SB, se carga un inmediato para sumarlo a la direccion actual del PC, y este sera la siguiente instruccion siempre y cuando se cumpla
    // la condicion del branch (funct3) que sale de una comparacion exitosa de la ALU (flag branch). 
    // No son necesarios RegDest, Ext_E y DWidth. Deshabilitamos RegWrite, MemWrite y MemRead. La operacion de la ALU dependera del funct3 y
    // Pcsrc dependera de si se cumple el branch o no.
    if ((OPcode == 99)) begin
        RegWrite = 0;
        ALUsrc = 0;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 1;
        Sel_Mux = 1;
        case (funct3)
            'h0: begin
                ALUop = 10;
            end
            'h1: begin
                ALUop = 11;
            end
            'h4: begin
                ALUop = 12;
            end
            'h5: begin
                ALUop = 14;
            end
            'h6: begin
                ALUop = 13;
            end
            'h7: begin
                ALUop = 15;
            end
            default: begin
                ALUop = 0;
            end
        endcase
        if ((branch == 1)) begin
            Sel_Mux = 1;
        end
        else begin
            Sel_Mux = 0;
        end
    end
    // Para la instruccion LUI, tipo U, se almacena un inmediato rellanado con 0's (Fill) en el registro deseado. Debemos habilitar la escritura en los registros (RegWrite=1), deshabilitar
    // la escritura y lectura de datos en la memoria RAM ya que no son necesarios, la siguiente instruccion de la PC es PC + 4 (PCsrc = 00) y seleccionamos la entrada
    // del fill a la escritura de los registros (RegDest=010). No son necesarrios ALUsrc, Ext_E ni DWidth.
    if ((OPcode == 55)) begin
        RegWrite = 1;
        RegDest = 2;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 1;
        Sel_Mux = 0;
    end
    // Para la instruccion AUIPC, tipo U, tomamos un inmediato de 20 bits de la instruccion, rellenamos con 0's los bits menos significativos para completar los 32 bits (Fill), se lo sumamos a la direccion actual de la PC y
    // lo almacenamos en el registro deseado. Para esto, habilitamos la escritura de los registros, hacemos que la entrada del registro sea la sumatoria del FIll con la direccion de PC (RegDest=001).
    // La siguiente instruccion del PC es PC + 4, entonces PCsrc = 00 y deshabilitamos la escritura y lectura de datos de la memoria RAM ya que no son necesarios.
    if ((OPcode == 23)) begin
        RegWrite = 1;
        RegDest = 1;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 1;
        Sel_Mux = 0;
    end
    // Para la instruccion JAL, tipo UJ, guardaremos la instruccion PC + 4 en el registro deseado. Ademas, tomamos un inmediato de la instruccion, la extendemos 
    // y se la sumamos a la direccion actual del PC. Este resultado sera la siguiente instruccion del PC. Para esto, habilitamos la escritura de los registros, 
    // hacemos que la entrada del registro sea PC + 4 (RegDest=000) y para indicar la siguiente instruccion del PC hacemos PCsrc = 1. Deshabilitamos la escritura
    // y lectura de datos de la memoria RAM ya que no son necesarios.
    // ALUsrc, ALUop, DWidth no son necesarios.
    if ((OPcode == 111)) begin
        RegWrite = 1;
        RegDest = 0;
        MemWrite = 0;
        MemRead = 0;
        PCsrc = 1;
        Sel_Mux = 1;
    end
end

endmodule
